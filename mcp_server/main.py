# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:15:05+00:00



import argparse
import json
import os
from typing import *
from typing import Optional
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Path, Query
from pydantic import conint

from models import (
    CompanyInfo,
    Customers,
    Disputes,
    LocationsResponse,
    Orders,
    PaymentMethods,
    Payments,
    ProductCategories,
    Products,
    TaxComponents,
    Transactions,
)

app = MCPProxy(
    contact={'email': 'support@codat.io', 'name': 'Codat'},
    description="Codat's Commerce API allows you to access standardised data from over 11 commerce and POS systems.\n\nStandardize how you connect to your customersâ€™ payment, PoS, and eCommerce systems. Retrieve orders, payouts, payments, and product data in the same way for all the leading commerce platforms.\n\n[Read more...](https://docs.codat.io/commerce-api/overview)\n\n[See our OpenAPI spec](https://github.com/codatio/oas) ",
    summary="Codat's standardized API for accessing commerce data ",
    termsOfService='https://www.codat.io/legals/',
    title='Commerce API',
    version='2.1.0',
    servers=[{'description': 'Production', 'url': 'https://api.codat.io'}],
)


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-customers',
    description=""" List all commerce customers for the given company and data connection """,
    tags=['customer_related_operations', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_customers(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List customers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-disputes',
    description=""" List commerce disputes """,
    tags=['dispute_resolution_process', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_disputes(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List disputes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-info',
    description=""" Retrieve information about the company, as seen in the commerce platform.

This may include information like addresses, tax registration details and social media or website information. """,
    tags=['company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_company_info(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get company info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-locations',
    description=""" Retrieve a list of locations as seen in the commerce platform.

A `location` is a geographic place at which stocks of products may be held, or from where orders were placed. """,
    tags=['company_data_access', 'location_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_locations(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List locations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-orders',
    description=""" Get a list of orders placed or held on the linked commerce platform """,
    tags=['order_tracking_and_management', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_orders(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-paymentMethods',
    description=""" Retrieve a list of payment methods, such as card, cash or other online payment methods, as held in the linked commerce platform. """,
    tags=['payment_processing_operations', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_payment_methods(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List payment methods
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-payments',
    description=""" List commerce payments for the given company & data connection. """,
    tags=['payment_processing_operations', 'transaction_record_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_payments(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List payments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-productCategories',
    description=""" Product categories are used to classify a group of products together, either by type (eg "Furniture"), or sometimes by tax profile. """,
    tags=['product_inventory_management', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_product_categories(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List product categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-products',
    description=""" The Products data type provides the company's product inventory, and includes the price and quantity of all products, and product variants, available for sale. """,
    tags=['product_inventory_management', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_products(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-taxComponents',
    description=""" This endpoint returns a lits of tax rates from the commerce platform, including tax rate names and values. This supports the mapping of tax rates from the commerce platform to the accounting platform. """,
    tags=['tax_information_handling', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_tax_components(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List tax components
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/connections/{connectionId}/data/commerce-transactions',
    description=""" Details of all financial transactions recorded in the commerce or point of sale system are added to the Transactions data type. For example, payments, service charges, and fees. """,
    tags=['transaction_record_management', 'company_data_access'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_transactions(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
